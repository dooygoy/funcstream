# Functional programming with Haskell

This is an exploration of a beautiful programming language Haskell and functional programming.
I am learning from several books and documenting the learning here. There are 
Haskell related links and I will attempt to write short reviews on each, and then
there are observation that are following books I currently read, often using
real life analogies and examples. 

I find that observing code not just through
numbers but through seemingly unrelated analogies enables me in turn to get a 
better grasp at numbers. When I try to explain some Haskell code to people who
do not know programming I notice they intuitively *do* get programming, it's just
the thing with numbers is that they can induce heavy feelings of guilt or remind
them on how bad were they in math which is only the fault of the teachers and 
their reluctance and to bring clarity that is also rich with a variety of
conceptual examples that are not just stiff images but life like analogies that
motivate and *remind* the human about processes they are familiar with that are in
their essence programming, and not just that but at their core, functional 
programming. There will be *errors* and before your vents go off please notice that 
I am thinking in what  you could call a *free jazz improvisational* method, or 
the so called Miles Davis *there are no wrong notes* method in which after you
make a mistake you do not *correct* the mistake but find a new turn from which
the wrong note, or sound will *sound* correct. Such exploration may be tedious
in the beginning, and yet this *spaced error repetition* eventually builds a 
different kind of knowledge, one that goes from errors to correctness, from
exploring a variety of *mistakes* to a much richer *correct* understanding of 
the issue at hand. It also reduces the memory footprint since by pruning the 
errors and developing from them, our understanding becomes capable of a much
wider web of connections. If one orients on just being correct it is possible to
induce higher stress levels since one is always striving for correctness.

> This is so because the subject matter is not exhausted in its *aims*; rather,
> it is exhaustively treated when it is *worked out*. Nor is the *result* which is
> reached the *actual* whole itself; rather, the whole is the result together with
> the way the result comes to be. The easiest thing of all is to pass judgements on
> what is substantial and meaningful. It is much more difficult to get a real grip 
> on it, and what is the most difficult of all is both to grasp what unites each of
> them and to give a full exposition of what that is.

### Table of contents
* [Books](#books)
* [Online Courses](#online-courses)
* [Talks](#talks)
* [Papers](#papers)
* [Blogs](#blogs)
* [Code](#code)
* [Inspirational](#inspirational)
* [Observations](#observations)

## Books
  * [A type of programming](https://atypeofprogramming.com/)
  * [Learn you a Haskell for Greater Good](http://learnyouahaskell.com/)
  * Richard Bird: Thinking Functionally with Haskell
  * Graham Hutton: Programming in Haskell
  * Simon Thompson: Haskell - The Craft of Functional Programming
  * Allen/Moronuki: Haskell From First Principles
  * Will Kurt: Get Programming with Haskell
  * Hudak/Quick: The Haskell School of Music
  * David S. Touretzky: Common Lisp: A Gentle Introduction to Symbolic Computation
  * Alejandro Serrano Mena: Practical Haskell - A Real World Guide to Programming
  * [Phil Freeman: Purescript by example](https://leanpub.com/purescript)
  * [Discrete Mathematics using a computer](http://www.x.edu.uy/inet/Springer.pdf)


## Online courses
  * [Bartosz Milewski Super Awesome Category Theory Lectures!](https://www.youtube.com/user/DrBartosz/playlists)
  * [Functional programming in Haskell: Supercharge your coding](https://www.futurelearn.com/courses/functional-programming-haskell)
  * [Bartosz Milewski - School of Haskell](https://www.schoolofhaskell.com/user/bartosz)
  * [Functional programming in Haskell](https://www.youtube.com/playlist?list=PLJ5C_6qdAvBFJP1RiUrUUJI4GEhnJhgQw)
  * [C9 Lectures: Dr. Erik Meijer - Functional Programming Fundamentals](https://youtu.be/UIUlFQH4Cvo)
  * [Haskell Summer Course](https://www.youtube.com/playlist?list=PLaAHmR4OoQXcrQl7kgkraWQAgQ-8FpEmS)
  * [Brent Yorgey - CSCI 360: Programming Languages (Fall 2016)](http://ozark.hendrix.edu/~yorgey/360/f16/)
    > from: [My new programming languages course](https://byorgey.wordpress.com/2017/01/13/my-new-programming-languages-course/) I decided to use class time in an unconventional way: for each class meeting I created a “module”, consisting of a literate Haskell file with some example code, explanatory text, and lots of holes where students needed to write answers to exercises or fill in code. I split the students into groups, and they spent class time just working through the module. Instead of standing at the front lecturing, I just wandered around watching them work and answering questions. It took a bit of getting used to—for the first few classes I couldn’t shake the feeling that I wasn’t really doing my job—but it quickly became clear that the students were really learning and engaging with the material in a way that they would not have been able to if I had just lectured.

    > A happy byproduct of this approach is that the modules are fairly self-contained and can now be used by anyone to learn the material. Reading through all the modules and working through the exercises should be a great option for anyone wishing to learn some basics of programming language design and implementation. For example, I know I will probably reuse it to get summer research students up to speed. Note that the course assumes no knowledge of Haskell (so those familiar with Haskell can safely skip the first few modules), but introduces just enough to get where I want to go.

## Talks

  * [Why is Haskell so Hard to Learn and How to Deal With It](https://youtu.be/RvRVn8jXoNY)
  * [Stop Treading Water: Learning to Learn](https://youtu.be/j0XmixCsWjs)
  * [Why algebraic data types are important - Bartosz Milewski ](https://youtu.be/LkqTLJK2API)
  * [PureScript: Tomorrow's JavaScript Today](https://youtu.be/5AtyWgQ3vv0)
  * [LambdaConf 2015 - Learn Functional Programming with PureScript John A De Goes](https://youtu.be/LqYfdmb0eUU)
  * [Adventures with Types - SPJ](https://youtu.be/6COvD8oynmI)
  * [Conal Elliott - Denotational Design: From Meanings to Programs](https://youtu.be/bmKYiUOEo2A)

## Papers
 * [Ralf Hinze collection of papers](https://www.cs.ox.ac.uk/people/ralf.hinze/publications/index.html)
 * [Graham Hutton: Universality and expressiveness of fold](http://www.cs.nott.ac.uk/~pszgmh/fold.pdf)
 * [Eugenio Moggi: Notions of computation and monads](https://person.dibris.unige.it/moggi-eugenio/ftp/ic91.pdf)
 * [Raul Rojas: A Tutorial Introduction to the Lambda Calculus](https://arxiv.org/pdf/1503.09060.pdf)
 * [Why calculating is better than scheming](https://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf)

## Blogs:

* [Steve Yegge - Execution in The Kingdom of Nouns](http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html)
> Hello, world! Today we're going to hear the story of Evil King Java and his quest for worldwide verb stamp-outage.
Caution: This story does not have a happy ending. It is neither a story for the faint of heart nor for the critical of mouth. If you're easily offended, or prone to being a disagreeable knave in blog comments, please stop reading now.
* [Letter to a Young Haskell Enthusiast](http://comonad.com/reader/2014/letter-to-a-young-haskell-enthusiast/)
> The following letter is not about what "old hands" know and newcomers do not. Instead, it is about lessons that we all need to learn more than once, and remind ourselves of. It is about tendencies that are common, and understandable, and come with the flush of excitement of learning any new thing that we understand is important, and about the difficulty, always, in trying to decide how best to convey that excitement and sense of importance to others, in a way that they will listen. It is written more specifically, but only because I have found that if we don't talk specifics as well as generalities, the generalities make no sense. This holds for algebraic structures, and it holds for other, vaguer concepts no less. It is a letter full of things I want to remember, as well as of advice I want to share. I expect I will want to remind myself of it when I encounter somebody who is wrong on the internet, which, I understand, may occur on rare occasion.
* [Monday Morning Haskell](https://mmhaskell.com/)
> At Monday Morning Haskell, we have tutorials for all levels of programmers! If you're new to Haskell, take a look at our Beginners series. If you have some experience with the language already, we've got some more Advanced material so you can get started on real world projects! Either way, come back every Monday morning for some new material on the Blog!
* [Why are partial functions (as in `head`, `tail`) bad?](https://www.reddit.com/r/haskell/comments/5n51u3/why_are_partial_functions_as_in_head_tail_bad/?utm_source=share&utm_medium=web2x)
>The problem with partial functions is that they're liars. Consider head: its type is [a] -> a, which means "give me a list of as and I'll give you an a". So I give it [] - does it give me an a? No, it doesn't, it throws an exception instead.
And when functions start lying about the things they return, you can no longer reason about them.
 * [Applied Haskell Syllabus](https://tech.fpcomplete.com/haskell/syllabus)
 > Applied Haskell is a commercial training program focusing on teaching intermediate Haskell. The goal is to help someone move from knowing Haskell basics to being able to write commercial software, with enough knowledge to pick up any new skills needed on demand.
 * [Haskell Learn - FPComplete](https://tech.fpcomplete.com/haskell/learn)
 * [An introduction to recursion schemes](https://blog.sumtypeofway.com/posts/introduction-to-recursion-schemes.html)
> Because nested structures appear in almost every problem domain and programming environment, from databases to 3D graphics to filesystems, the act of iterating through these structures is common, so common that most programmers barely notice when they’re doing it. As such, generalizing the act of recursive traversals provides immediate real-world benefits: our new generalized traversal can replace a host of type-specific traversal functions. In addition, by decoupling how a function recurses over data from what the function actually does, we reduce cognitive overhead and can focus entirely on the core behavior of our recursive functions.
 * [The Road to Proficient Haskell](https://williamyaoh.com/posts/2020-01-11-road-to-proficient.html)
 * [Getting started with Haskell](https://stackoverflow.com/questions/1012573/getting-started-with-haskell/1016986#1016986)
 * [You Could Have Invented Monads](http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html)
 > In fact, I hope to get you to invent them now if you haven't already. It's then a small step to notice that all of these solutions are in fact the same solution in disguise. And after reading this, you might be in a better position to understand other documents on monads because you'll recognise everything you see as something you've already invented.
 * [How To Do Basic Error Handling Logging](https://williamyaoh.com/posts/2019-10-12-how-to-basic-error-handling-logging.html)
 * [Basic Haskell: An Examination of a Todo List](https://www.benlopatin.com/basic-haskell-todo/)
 * [Standardized ladder of functional programming](https://pbs.twimg.com/media/CydL5EYUsAAI-61.jpg:large)
 * [Sum Types](https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types)
 * [How Laziness works](https://two-wrongs.com/how-laziness-works)
 > What I'm about to describe is completely useless to learn how to write Haskell, but if you're like me and like poking at things under the hood, by all means join in.
 * [Space Leak Zoo](http://blog.ezyang.com/2011/05/space-leak-zoo/)
 > There are a few different types of space leak here, but they are quite different and a visitor would do well not to confuse them (the methods for handling them if encountered in the wild vary, and using the wrong technique could exacerbate the situation).
 * [Money in the type system where it belongs](https://ren.zone/articles/safe-money)
 > Notwithstanding the value civilization gives to a particular currency, the amount of said currency one owns can't spontaneously increase nor decrease in number. As programmers, we do play a crucial role in ensuring amounts of currency are never made up nor lost. In this article we will explore how we can leverage types, functional programming, and in particular the safe-money Haskell library to ensure that our software deals with monetary values and world currencies as carefully as civilization requires. Mostly, we will be exploring the type system and learning how to reason through types.
 * [Embedding Linear Lambda Calculus, Quickly and Easily](https://blog.functorial.com/posts/2017-08-05-Embedding-Linear-Lambda-Calculus.html)
  > Suppose you want to create an embedded DSL based on the linear lambda calculus. Why might you want to do this? Well, you might want to control access to some resource, or perhaps you've heard that linear types can change the world and now you'd like to compile your EDSL to some target language and optimize things using mutable data structures.
 * [Imperative Haskell](https://vaibhavsagar.com/blog/2017/05/29/imperative-haskell/)
  > I was working through Tim Roughgarden’s Algorithms 1 (which has now been replaced by two smaller courses) and attempting to do all the exercises in Haskell when I bumped up against an uncomfortable truth.
 * [An Opiniated Guide to Haskell in 2018](https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/)
 > In the meantime, in the interest of both sharing with others the small amount of wisdom I’ve gained and preserving it for my future self, I’ve decided to write a long, rather dry overview of a few select parts of the Haskell workflow I developed and the ecosystem I settled into.
 * [Functor-Oriented Programming](http://r6.ca/blog/20171010T001746Z.html)
 > My style of Haskell programming has been evolving over the 15 years that I have been working with it. It is turning into something that I would like to call “functor oriented programming”. The traditional use of typed functional programming focuses on data types. One defines data types to model the data structures that your program operates on, and one writes functions to transform between these structures. One of the primary goals in this traditional methodology is to create data structures that exclude erroneous states to the extent that is reasonably possible. As long as one ensures that pattern matching is complete, then the type system catches many errors that would otherwise lead to these erroneous states, which have been crafted to be unrepresentable. Functor oriented programming is a refinement of this traditional focus on data types.

## Code

 * [Lambda launcher](https://github.com/balsoft/lambda-launcher)
 * [Input Output](https://github.com/input-output-hk)
 * [Input Output/Plutus](https://github.com/input-output-hk/plutus)
 * [Awesome Haskell List](https://github.com/krispo/awesome-haskell)
 * [Chris Done - a demo web browser engine](https://github.com/chrisdone/vado)
 > This is a demonstration program that is able to load a web page up and render it like in the early 90's. It supports laying out text, different font sizes for headings, inline and block elements, hyperlinks, bold and italics. It supports mousewheel scrolling, too. I wrote this in a couple evenings, because it seemed straight-forward to do so given the libraries available today. That's a good sign for Haskell. Also, there's an inarticulate gut feeling I have that tells me maybe it's worth celebrating these days in which the web is still viewable in its simplest, earliest form.
 * [Chris Done - subset of Haskell, aimed at aiding teachers teach Haskell](https://github.com/chrisdone/duet)

```
 $ duet run demo.hs
(\x -> x + 5) (2 * 3)
(2 * 3) + 5
6 + 5
11
```
## Inspirational

* [Wallace Stevens - Thea idea of order at Key West](https://www.poetryfoundation.org/poems/43431/the-idea-of-order-at-key-west)
>  The sea was not a mask. No more was she.
The song and water were not medleyed sound
Even if what she sang was what she heard,
Since what she sang was uttered word by word.
It may be that in all her phrases stirred
The grinding water and the gasping wind;
But it was she and not the sea we heard.

## Observations

  * Explaining Haskell datatypes and constructors to a buddhist/yogi
by using the chakra system and seed sounds of each chakra analogy:

```
soundToChakra :: Sound -> Chakra
soundToChakra = \x ->
  case x of
    Lam -> Muladhara
    Vam -> Svadishtana
    Ram -> Manipura
    Yam -> Anahata
    Ham -> Vishuddha
    Aum -> Ajna

stringToSound :: String -> Maybe Sound
stringToSound = \x ->
  case x of
    "lam" -> Just Lam
    "vam" -> Just Vam
    "ram" -> Just Ram
    "yam" -> Just Yam
    "ham" -> Just Ham
    "aum" -> Just Aum
    _     -> Nothing
```
  * What is interesting is that in Haskell you don't say, "well, maybe this or maybe
that" like I hear often people say in real life, and true, it does seem
ambiguous to use maybe for more possibilities than one or nothing at all. You
instead say "Well, maybe just this or nothing at all" and if you want to express
more outputs, or results that involve something more than just nothing you use
"Well, either this or that". But even more, the `Maybe` is actually made of
"Just this or nothing at all" so there is always this layered approach to
composition of functions, of expressions. The `Maybe` itself is defined by
`Just` this or `Nothing` at all. Why? Well, It seems it is because we can call
it `Maybe` precisely because it somehow produces an *action* and a terminating
*non-action*; we can also visualise it as a parent node whose name is Maybe with
two children, named Just and Nothing. This intuitive tricky part is that Nothing
is not like Just, Just will eventually pass something while Nothing will just
say no to what ever is being passed on, simply declaring Nothing if or Maybe
gets something which it doesn't need, which is not defined explicitly. In
Haskell it seems each expression can have a name itself, so that it is possible
to connect it to anything else, while at the same time it is defined *totally*
or at least that is what we strive to do. In real life we sometimes use a name
for an expression and then offer an explanation of what we really mean. We even
might get irritated if we are asked to explain our *Maybe's*.

> Alice: "Are you gonna do it?"
Bob: "Maybe"
Alice: "What do you mean maybe?"
Bob: "Well I mean that I am going to just do it or I am going to `Just` sit back
and do `Nothing`.
Alice: "But Bob please if you can't do it then do the other thing please, you
can't `Just` sit back and do `Nothing`.
Bob: "Ok then, I am going to do `Either` this thing or that thing if you need it
so much, is that ok? *Just* give me some time.

Yet people often use the word maybe for more than one thing. You could maybe do
this, or you could maybe do that, or bla.. which does seem a bit *unprecise*.


```
fromEither :: Either Sound Chakra -> ThisOrThat
fromEither = \x ->
  case x of
    Left s -> This s
    Right c -> That c

toEither :: ThisOrThat -> Either Sound Chakra
toEither = \x ->
  case x of
    This s -> Left s
    That c -> Right c
```

```
Right Chakra == toEither (fromEither (Right Chakra))
That Chakra == fromEither (toEither (That Chakra))
```

So `That` is on our `Right` and `This` is on our `Left`. `That` contains
all the 6 chakras we have in our body and `This` contains all the sounds we
utter that work on each chakra. The intuitive distinction that might seem
hard to grasp is that we seem to have another layer when we visualise
the either containers, or better to say when we visualise the path from
chakra container to sound container. We cannot just visualise sound and chakra
flowing between but instead we must so to say go up the tree root using
two levels of Either to understand the whole structure, this needs to be done
in order for us to prove they all relate, that they are all *isomorphic*
to one another.

```
                   This                             That
                  6 sounds                        6 chakras
                    \             fromEither          /
                     \          /    |       \       /
                      \        /     |        \     /
                       \      /      |         \   /
                       Left          +           Right
                         \                       /
                          \                     /
                           \                   /

                                     *
                                     |
                                     |
                                     |
                                  toEither

                    Right Chakra == toEither (fromEither (Right Chakra))
                    That Chakra == fromEither(toEither (That Chakra))

                    Left Sound == toEither (fromEither (Left Sound))
                    This Sound == fromEither (toEither (This Sound))
```
> `Either sound chakra` is making a statement saying that we have *one* of two possible values of types x *or* y in it. It turns out that `Either`, or *sum types* more generally, have a very reasonable and useful *dual* construction in which we have *both x and y*. In Haskell, we can convey thia idea as well. Let's call it `Pair`.

`data Pair x y = MakePair x y`

That is, a pair of a Chakra and a Sound will have type `Pair Chakra Sound`.
So while with `Maybe` we had to just pick one or nothing at all, and in `Either` we could pick this or that, which were some real alternatives, in a `Pair` we have this notion of carrying both alternatives with us, they are together and we are not making a choice by choosing either this or that.
It does seem like `Maybe` relates somehow to the notion of `Identity` since it is just giving us the thing we ask while the Either resembles to a Boolean choice or either this or that, either though we could say `Maybe` as well resembles a boolean choice since Just could be understood as `true` and Nothing as `false`. It is interesting to find relations with basic mathematical functions. In that case `Either` could be understood as showing two truth values and yet we are only supposed to pick one, now that really resembles to `OR`! But bool values always pick just one so even though this thought process *smells* wrong it does bring benefit when learning Haskell to compare it with previous concepts.

> Quote from atop: 
We say `Either` and `Pair` are fundamental because once we can group or tell
apart two things, we can group or tell apart as many things as we want.

Once we begin to extend our space of pairs we realize pairs are just like
containers of two. Can we imagine triples? Or quads? If we jump to a musical
analogy, a pair is a musical interval, a pair of two tones in any scale makes an
interval. Once we hear a tone it is like hearing a point in space, though it can
sound pretty we know very little about it since the whole sound is coming from
one source (aha but what when both sources sing the same tone? Where is the
source then?). To get back a pair of two tones is like a line, and a triplet of
three tones can be understood as a triangle, a musical chord, defining a space between three
tones. Technically speaking a musical chord is a cluster of three or more tones.
Let us add three tones, c, e, and g that will make a C chord

```haskell
add3tones :: (Tone, Tone, Tone) -> Tone
add3tones = \(c, e, g) -> c + e + g 
```
--------------------------------------------------------------------

### Let vs Where

It seems the difference between let and where lies in the order of declaration.
When we want to first name the *things* we want to use in our action we use let
in the sense, let there be light, let there be this, let there be that and then
after we have declared all out *lets* we will begin an action like "ok now
create this". We could understand it like this as well:
```haskell
let there be a human called "Bob"
let there be a human called "Alice"
in "Alice" loves "Bob"

-- further

let human = "Bob"
let human = "Alice"
"Bob" loves "Alice"

-- further we ommit using let twice

let firstHuman = "Bob"
    secondHuman = "Alice"
in "Bob" loves "Alice"

{- 
This was not valid Haskell code, but it is written like this in order to
increase conceptual understanding of let vs where expressions
-}

-- valid Haskell 

let x = 2
    y = 3
in x + y
```

Now, when we use `where` we like to first define our action or an event happening
and then tell something about our actors who define the event itself. Something
like "where some event is happening, its components are this and that, or where
Alice loves Bob, Bob is human and Alice is human too." If we miss describing a
single component of our event the event will not compile, Haskell will not
accept our declaration. Notice we could define a component and not use it in our
action, but it will still go through, and the event will not fail, same as declaring "Alice",
"Bob" and "Hayka" and then telling "Alice" loves "Hayka", the program would run
even though "Bob" was left all by himself.

The above let expression can be written with where like:

```haskell
love = human1 + human3
  where human1 = "Bob"
        human2 = "Alice"
        human3 = "Hayka"
```
Let's use correct Haskell code for our love program. We will use '++' instead
of just '+' since '++' is used to add or *concatenate* words, aka strings 
(of characters).

```haskell
love = human2 ++ " loves  " ++  human3
  where human1 = "Bob"
        human2 = "Alice"
        human3 = "Hayka"

-- and our previous number example with let

add = x + y
  where x = 2
        y = 3
       		

	
	
