## Side benefits over side effects

I begin to write about learning a pure functional programming 
language named Haskell. By documenting my learning process 
I observe my thought patterns and express appearing 
transformations in words. I begin to understand this process 
as a stream of data structures consisting of units which we will call thunks, 
little lego like units of thought. Thoughts seem to appear like clusters of data. 
Even though I get influenced by occuring mental side effects in my learning, more so since I am a beginner I go back to correct and morph 
the wavy direction line into a straight line. In order for us to 
understand intelligence maybe we do need to document our mind 
stream in real time as it is happening to understand better 
how we express ourselves. I notice there is a huge benefit 
in realizing these tiny strands and working dilligently 
on our abstract expression engine. It seems like an endless 
recursive process that comes with constant side benefits 
which are eliminating repetition and  even bringing a 
mental relaxation. This relaxation seems like a 
necessary ingredient.

Haskell seems like a very difficult language at first, it is 
so clear and simple. I tried learning Haskell and Lisp for 
years by much reading and I feel I cannot write a single 
program that solves something substantial. What I do notice 
is that my understanding increases, as if the space of it 
extends effortlessly. Haskell is made of expressions which 
we call functions that receive inputs and express an output. 
These expressions are called pure functions by mathematicians. 
We understand a function is pure where it expresses itself 
completely, taking a single argument or more arguments and 
producing a single result, not more results, not different 
results, always a same result. When a function is called 
with the same argument, it returns the same value. Always. 
This is what we call referential transparency. Again it 
seems more effective to say referential transparency than 
always. Mathematical terms are cool too and often exclude 
any notion of side effectual humanistic emotions that can 
appear when we use a word such as always. 
What is always anyway?

Will Kurt writes in his book on Haskell:

> Even if we're not exactly right, this reasoning gives us insight into our question. If you aren't passing an argument to a function, you must be accessing a value in your environment, and if you aren't returning a value, you must also be changing a value in your environment. When you change a value in your programming environment, you're changing the program's state. Changing state creates side effects in your code, and these side effects can make code hard to reason about and therefore unsafe.

Let us imagine an every day example. We are in a market store looking to buy some items and we find our selves comparing the prices of items of different weight or packaging. This could be chunks of cheese randomly packaged in different sizes. This happens often and sellers have various pricing methods, sometime smaller units being more expensive that larger units of the same product. Next thing you want to find out is what is the price of a single unit of cheese of some weight, and compare it with a different cheese of a similar weight. The only way we could learn the true price is to compare the prices of cheese in one Kilo/Pound units. So one kilo of Gauda costs 10 dollars and one kilo of Emmentaler costs 12 dollars. So accordingly we see which cheese will get us more cheese even though at first the more expensive cheese seemed cheaper because of the smaller packaging. This could be expressed as a haskell program which would significatly reduce this huge paragraph of words. I still do not know how to express this as pure code though this writing marks the beginning of understanding of this process

Let us look at the Graham Hutton definition of a function from his book on Haskell. 

>In Haskell, a function is a mapping that takes one or more arguments and produces a single result, and is defined using an equation that gives a name for the function, a name for each of its arguments, and a body that specifies how the result can be calculated in terms of the arguments. 

While I think about this quote, as I begin to understand it, or we can say parse its meaning, I notice how I process the definition and how occuring transformations affect my understanding. I notice the connectedness and totality of this definition, after I read it I think this might be one of the best definitions I ever read. This observation is not just an empty platitude but a clear recognition of the suble process. Reading this definition makes me think more about it, at first just repeating the words, then learning them by heart after which I begin to analyse the structure of the sentence itself. Graham is a Haskell master with several books under his belt so his understanding is deepened by practice and calm understanding. We can notice that when a simple explanation (not just easy) may contain the essence of a whole programming language. What do I mean by that? I mean that an expert will be affected by the language itself when expressing opinions about the same language. Is that a curse or a good thing? Our minds have an ability to adapt to anything with or without us knowingly being aware of the adaptation that is happening. Now, how do I understand this definition right now? There is feeling of sensing something greater yet structurally natural and compact, like a pretty geometrical shape with its symmetries and reflections. Compare this with a feeling of sensing or touching a round spherical body, seeing a cube, or seeing a mandala like surwace where we have higher degrees of reflections all emanating from a single center. Would a mandala constitute a pure function since it produces a single result in every direction?

Notice the visual dimension of this definition. It almost requires no understanding or learning of a control flow process, like going from A to B, then doing C. It is not an instruction but a pure definition, its purity tempting us to look for more of it too! It reminds us of a Mozart melody which is so perfectly symmetrical where you have nothing to add or take away and even if you did it would be strangely noticable.

```
in haskell,
    a function is a mapping that
    takes (one or more) arguments
    and produces a single result
  and is defined using an equation that
    gives a name for the function
          a name for each of its arguments
          a body that specifies
            how the result can be calculated
                in terms of the arguments
--
--
 a function is a mapping that takes
    (one or more) arguments and produces
    a single result
        and is defined using
        an equation that gives
            a name for the function
            a name for each of its arguments
            a body that specifies how
                the result can be calculated
                    in terms of the arguments
```


What I notice is how Haskell influences my mind stream in a non intrusive way, morphing its patterns silently, functionally clearing the obstacles by constantly rearranging small thunks into understandable units, softly echoing old patterns, illuminating their repetitive resonance. While I express functionally, I reflect each turn, thus making no turns, I begin unknowingly to understand the essence of lazy evaluation. What is lazy evaluation? Lazy evaluation is like doing a step only when you need it not before you need it. I need to study more to express cleary. I am learning **Emacs** editor to better document, **github** so that I can better follow, and **NixOS** too, a declarative functional Linux OS distribution which helps me stay functional even when I interact with my daily OS. Also these three tools are functional in their nature and they help me deepen the understanding of the functinal approach while mixing different levels of interactions. Stay tuned and remember to commit!





